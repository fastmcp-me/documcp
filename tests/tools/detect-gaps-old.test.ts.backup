import { promises as fs } from 'fs';
import path from 'path';
import { tmpdir } from 'os';

// Mock dependencies that don't involve filesystem
const mockAnalyzeRepository = jest.fn();
const mockValidateContent = jest.fn();

jest.mock('../../src/tools/analyze-repository.js', () => ({
  analyzeRepository: mockAnalyzeRepository,
}));

jest.mock('../../src/tools/validate-content.js', () => ({
  handleValidateDiataxisContent: mockValidateContent,
}));

jest.mock('../../src/utils/code-scanner.js', () => ({
  CodeScanner: jest.fn().mockImplementation(() => ({
    analyzeRepository: jest.fn().mockResolvedValue({
      summary: {
        totalFiles: 5,
        parsedFiles: 3,
        functions: 10,
        classes: 2,
        interfaces: 3,
        types: 1,
        constants: 2,
        apiEndpoints: 1,
      },
      files: ['src/test.ts'],
      functions: [
        { name: 'testFunction', filePath: 'src/test.ts', line: 1, exported: true, hasJSDoc: false },
      ],
      classes: [
        { name: 'TestClass', filePath: 'src/test.ts', line: 5, exported: true, hasJSDoc: false },
      ],
      interfaces: [
        {
          name: 'TestInterface',
          filePath: 'src/test.ts',
          line: 10,
          exported: true,
          hasJSDoc: false,
        },
      ],
      types: [],
      constants: [],
      apiEndpoints: [],
      imports: [],
      exports: [],
      frameworks: [],
    }),
  })),
}));

// Helper functions for creating test directories and files
async function createTestDirectory(name: string): Promise<string> {
  const testDir = path.join(tmpdir(), 'documcp-test-' + Date.now() + '-' + Math.random().toString(36).substring(7));
  await fs.mkdir(testDir, { recursive: true });
  return testDir;
}

async function createTestFile(filePath: string, content: string): Promise<void> {
  await fs.mkdir(path.dirname(filePath), { recursive: true });
  await fs.writeFile(filePath, content);
}

async function cleanupTestDirectory(dirPath: string): Promise<void> {
  try {
    await fs.rm(dirPath, { recursive: true, force: true });
  } catch (error) {
    // Ignore cleanup errors
  }
}

// Now import the module under test
import { detectDocumentationGaps } from '../../src/tools/detect-gaps.js';

describe('detectDocumentationGaps', () => {
  const mockRepositoryAnalysis = {
    id: 'analysis_123',
    structure: {
      hasTests: true,
      hasCI: true,
      hasDocs: true,
    },
    dependencies: {
      ecosystem: 'javascript',
      packages: ['react', 'express'],
    },
    hasApiEndpoints: true,
    packageManager: 'npm',
    hasDocker: true,
    hasCICD: true,
  };

  const mockValidationResult = {
    success: true,
    confidence: { overall: 85 },
    issues: [{ type: 'warning', description: 'Missing API examples' }],
    validationResults: [
      { status: 'pass', message: 'Good structure' },
      { status: 'fail', message: 'Missing references', recommendation: 'Add API docs' },
    ],
  };

  let testRepoDir: string;
  const createdDirs: string[] = [];

  beforeEach(async () => {
    jest.clearAllMocks();

    // Create a fresh test directory for each test
    testRepoDir = await createTestDirectory('test-repo');
    createdDirs.push(testRepoDir);

    // Default successful repository analysis
    mockAnalyzeRepository.mockResolvedValue({
      content: [
        {
          type: 'text',
          text: JSON.stringify(mockRepositoryAnalysis),
        },
      ],
    });

    // Default validation result
    mockValidateContent.mockResolvedValue({
      content: [
        {
          type: 'text',
          text: JSON.stringify({ success: true, data: mockValidationResult }),
        },
      ],
    } as any);
  });

  afterEach(async () => {
    // Cleanup all created directories
    await Promise.all(createdDirs.map(dir => cleanupTestDirectory(dir)));
    createdDirs.length = 0;
  });

  describe('successful gap detection', () => {
    it('should detect gaps in repository without documentation', async () => {
      // No docs directory created - test repo is empty

      const result = await detectDocumentationGaps({
        repositoryPath: testRepoDir,
        depth: 'quick',
      });

      expect(result.content).toBeDefined();
      expect(result.content[0]).toBeDefined();
      const data = JSON.parse(result.content[0].text);

      expect(data.repositoryPath).toBe(testRepoDir);
      expect(data.analysisId).toBe('analysis_123');
      expect(data.overallScore).toBe(0);
      expect(data.gaps).toContainEqual(
        expect.objectContaining({
          category: 'general',
          gapType: 'missing_section',
          description: 'No documentation directory found',
          priority: 'critical',
        }),
      );
    });

    it('should detect missing Diataxis sections', async () => {
      // Create docs directory with some sections but missing tutorials and how-to
      const docsDir = path.join(testRepoDir, 'docs');
      await fs.mkdir(docsDir);
      await createTestFile(path.join(docsDir, 'index.md'), '# Main Documentation');

      // Create reference and explanation sections
      await fs.mkdir(path.join(docsDir, 'reference'));
      await createTestFile(path.join(docsDir, 'reference', 'api.md'), '# API Reference');
      await fs.mkdir(path.join(docsDir, 'explanation'));
      await createTestFile(path.join(docsDir, 'explanation', 'concepts.md'), '# Concepts');

      // tutorials and how-to are missing

      const result = await detectDocumentationGaps({
        repositoryPath: testRepoDir,
        documentationPath: docsDir,
        depth: 'standard',
      });

      const data = JSON.parse(result.content[0].text);

      expect(data.gaps).toContainEqual(
        expect.objectContaining({
          category: 'tutorials',
          gapType: 'missing_section',
          priority: 'high',
        }),
      );
      expect(data.gaps).toContainEqual(
        expect.objectContaining({
          category: 'how-to',
          gapType: 'missing_section',
          priority: 'medium',
        }),
      );
    });

    it('should detect technology-specific gaps', async () => {
      // Mock existing docs but missing tech-specific content
      mockStat.mockResolvedValue({ isDirectory: () => true } as any);
      mockReaddir.mockImplementation((dirPath: any) => {
        if (String(dirPath).includes('/tutorials')) {
          return Promise.resolve(['getting-started.md'] as any);
        }
        return Promise.resolve(['index.md'] as any);
      });

      const result = await detectDocumentationGaps({
        repositoryPath: '/test/repo',
        documentationPath: '/test/repo/docs',
      });

      const data = JSON.parse(result.content[0].text);

      // Should detect API documentation gap
      expect(data.gaps).toContainEqual(
        expect.objectContaining({
          category: 'reference',
          description: 'API endpoints detected but no API documentation found',
          priority: 'critical',
        }),
      );

      // Should detect Docker documentation gap
      expect(data.gaps).toContainEqual(
        expect.objectContaining({
          category: 'how-to',
          description: 'Docker configuration found but no Docker documentation',
        }),
      );
    });

    it('should identify existing strengths', async () => {
      // Mock well-organized documentation
      mockStat.mockResolvedValue({ isDirectory: () => true } as any);
      mockReaddir.mockImplementation((dirPath: any) => {
        if (String(dirPath).includes('/docs')) {
          return Promise.resolve([
            'index.md',
            'tutorials',
            'how-to',
            'reference',
            'explanation',
          ] as any);
        }
        return Promise.resolve(['getting-started.md', 'advanced.md'] as any);
      });

      const result = await detectDocumentationGaps({
        repositoryPath: '/test/repo',
        documentationPath: '/test/repo/docs',
      });

      const data = JSON.parse(result.content[0].text);

      expect(data.strengths).toContain('Has main documentation index file');
      expect(data.strengths).toContain(
        'Well-organized sections: tutorials, how-to, reference, explanation',
      );
    });

    it('should calculate accurate coverage scores', async () => {
      // Mock complete documentation structure
      mockStat.mockResolvedValue({ isDirectory: () => true } as any);
      mockReaddir.mockImplementation((dirPath: any) => {
        return Promise.resolve(['content1.md', 'content2.md'] as any);
      });

      const result = await detectDocumentationGaps({
        repositoryPath: '/test/repo',
        documentationPath: '/test/repo/docs',
      });

      const data = JSON.parse(result.content[0].text);

      expect(data.contentCoverage.tutorials).toBe(60);
      expect(data.contentCoverage.howTo).toBe(60);
      expect(data.contentCoverage.reference).toBe(60);
      expect(data.contentCoverage.explanation).toBe(60);
      expect(data.overallScore).toBeGreaterThan(10);
    });

    it('should handle existing analysis ID reuse', async () => {
      const existingAnalysisId = 'existing_analysis_456';

      const result = await detectDocumentationGaps({
        repositoryPath: '/test/repo',
        analysisId: existingAnalysisId,
      });

      const data = JSON.parse(result.content[0].text);

      expect(data.analysisId).toBe(existingAnalysisId);
      expect(mockAnalyzeRepository).not.toHaveBeenCalled();
    });
  });

  describe('error handling', () => {
    it('should handle repository analysis failure', async () => {
      mockAnalyzeRepository.mockResolvedValue({
        content: [
          {
            type: 'text',
            text: JSON.stringify({ success: false }),
          },
        ],
      });

      const result = await detectDocumentationGaps({
        repositoryPath: '/invalid/repo',
      });

      const response = JSON.parse(result.content[0].text);

      expect(response.success).toBe(false);
      expect(response.error.code).toBe('GAP_DETECTION_FAILED');
      expect(response.error.message).toContain('Repository analysis failed');
    });

    it('should handle validation errors gracefully', async () => {
      // Ensure analyze repository succeeds
      mockAnalyzeRepository.mockResolvedValue({
        content: [
          {
            type: 'text',
            text: JSON.stringify(mockRepositoryAnalysis),
          },
        ],
      });

      mockValidateContent.mockRejectedValue(new Error('Validation failed'));

      // Mock fs operations for analyzeExistingDocumentation
      mockStat.mockImplementation(async (filePath: string) => {
        if (filePath.includes('docs')) {
          return { isDirectory: () => true };
        }
        throw new Error('Not found');
      });

      mockReaddir.mockImplementation(async (dirPath: string) => {
        if (dirPath.includes('docs')) {
          return ['index.md'];
        }
        return [];
      });

      const result = await detectDocumentationGaps({
        repositoryPath: '/test/repo',
        documentationPath: '/test/repo/docs',
      });

      // Should still work without validation
      const response = JSON.parse(result.content[0].text);
      expect(response.analysisId).toBe('analysis_123');
      expect(response.gaps).toBeInstanceOf(Array);
      expect(response.gaps.length).toBeGreaterThan(0);
    });

    it('should handle file system errors', async () => {
      mockStat.mockRejectedValue(new Error('Permission denied'));

      const result = await detectDocumentationGaps({
        repositoryPath: '/restricted/repo',
      });

      const response = JSON.parse(result.content[0].text);
      expect(response.analysisId).toBe('analysis_123');
      expect(response.gaps).toBeInstanceOf(Array);
      expect(response.gaps.length).toBe(1);
      expect(response.gaps[0].description).toBe('No documentation directory found');
    });
  });

  describe('recommendation generation', () => {
    it('should generate immediate recommendations for critical gaps', async () => {
      mockStat.mockRejectedValue(new Error('ENOENT')); // No docs exist

      const result = await detectDocumentationGaps({
        repositoryPath: '/test/repo',
      });

      const response = JSON.parse(result.content[0].text);

      expect(response.analysisId).toBe('analysis_123');
      expect(response.recommendations.immediate).toContain(
        'Create documentation structure using setup_structure tool',
      );
    });

    it('should prioritize recommendations correctly', async () => {
      // Mock mixed scenario - some docs exist, some missing
      mockStat.mockImplementation((dirPath: any) => {
        if (String(dirPath).includes('/tutorials')) {
          return Promise.reject(new Error('ENOENT'));
        }
        return Promise.resolve({ isDirectory: () => true } as any);
      });

      mockReaddir.mockResolvedValue(['existing.md'] as any);

      const result = await detectDocumentationGaps({
        repositoryPath: '/test/repo',
        documentationPath: '/test/repo/docs',
      });

      const response = JSON.parse(result.content[0].text);

      expect(response.analysisId).toBe('analysis_123');
      expect(response.recommendations).toBeDefined();
      expect(response.recommendations.immediate.length).toBeGreaterThan(0);
      expect(response.gaps.some((gap: any) => gap.priority === 'high')).toBe(true);
    });
  });

  describe('input validation', () => {
    it('should handle invalid depth parameter', async () => {
      await expect(
        detectDocumentationGaps({
          repositoryPath: '/test/repo',
          depth: 'invalid' as any,
        }),
      ).rejects.toThrow();
    });

    it('should require repositoryPath', async () => {
      await expect(
        detectDocumentationGaps({
          documentationPath: '/test/docs',
        } as any),
      ).rejects.toThrow();
    });
  });
});
