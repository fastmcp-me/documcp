<h1>ADR-007: MCP Prompts and Resources Integration for AI Assistance</h1>
<hr>
<h2>id: 007-mcp-prompts-and-resources-integration
title: 'ADR-007: MCP Prompts and Resources Integration'
sidebar_label: 'ADR-7: MCP Prompts and Resources Integration'
sidebar_position: 7</h2>
<h2>Status</h2>
<p>Proposed</p>
<h2>Context</h2>
<p>DocuMCP needs AI assistance capabilities, and the Model Context Protocol provides native support for exactly this use case through <strong>Prompts</strong> and <strong>Resources</strong>. Rather than extending the protocol, we should leverage MCP's built-in capabilities:</p>
<ul>
<li><strong>MCP Prompts</strong>: Pre-written templates that help users accomplish specific tasks</li>
<li><strong>MCP Resources</strong>: File-like data that can be read by clients (like API responses, file contents, or generated documentation)</li>
</ul>
<p>Current MCP Core Concepts that we can utilize:</p>
<ol>
<li><strong>Tools</strong>: Interactive functions (already implemented - analyze_repository, recommend_ssg, etc.)</li>
<li><strong>Prompts</strong>: Template-based assistance for common workflows</li>
<li><strong>Resources</strong>: Readable data and content that clients can access</li>
</ol>
<p>This approach maintains full MCP compliance while providing rich AI assistance through the protocol's intended mechanisms.</p>
<h2>Decision</h2>
<p>We will implement AI assistance using MCP's native <strong>Prompts</strong> and <strong>Resources</strong> capabilities, providing pre-written prompt templates for documentation workflows and exposing generated content through the MCP resource system.</p>
<h3>Core Implementation Strategy:</h3>
<h4>1. MCP Prompts for Documentation Workflows</h4>
<pre><code class="language-typescript">// Implement MCP ListPromptsRequestSchema and GetPromptRequestSchema
const DOCUMENTATION_PROMPTS = [
  {
    name: &quot;analyze-and-recommend&quot;,
    description: &quot;Complete repository analysis and SSG recommendation workflow&quot;,
    arguments: [
      { name: &quot;repository_path&quot;, description: &quot;Path to repository&quot;, required: true },
      { name: &quot;priority&quot;, description: &quot;Priority: simplicity, features, performance&quot; }
    ]
  },
  {
    name: &quot;setup-documentation&quot;,
    description: &quot;Create comprehensive documentation structure with best practices&quot;,
    arguments: [
      { name: &quot;project_name&quot;, description: &quot;Project name&quot;, required: true },
      { name: &quot;ssg_type&quot;, description: &quot;Static site generator type&quot; }
    ]
  },
  {
    name: &quot;troubleshoot-deployment&quot;,
    description: &quot;Diagnose and fix GitHub Pages deployment issues&quot;, 
    arguments: [
      { name: &quot;repository_url&quot;, description: &quot;GitHub repository URL&quot;, required: true },
      { name: &quot;error_message&quot;, description: &quot;Deployment error message&quot; }
    ]
  }
];
</code></pre>
<h4>2. MCP Resources for Generated Content</h4>
<pre><code class="language-typescript">// Implement ListResourcesRequestSchema and ReadResourceRequestSchema  
interface DocuMCPResource {
  uri: string;        // e.g., &quot;documcp://analysis/repo-123&quot;
  name: string;       // Human-readable name
  description: string; // What this resource contains
  mimeType: string;   // Content type
}

// Resource types we'll expose:
const RESOURCE_TYPES = [
  &quot;documcp://analysis/{analysisId}&quot;,      // Repository analysis results
  &quot;documcp://config/{ssgType}/{projectId}&quot;, // Generated configuration files
  &quot;documcp://structure/{projectId}&quot;,      // Documentation structure templates
  &quot;documcp://deployment/{workflowId}&quot;,    // GitHub Actions workflows
  &quot;documcp://templates/{templateType}&quot;,   // Reusable templates
];
</code></pre>
<h4>3. Integration with Existing Tools</h4>
<ul>
<li><strong>Tools remain unchanged</strong>: analyze_repository, recommend_ssg, generate_config, etc.</li>
<li><strong>Prompts provide workflows</strong>: Chain multiple tool calls with guided prompts</li>
<li><strong>Resources expose results</strong>: Make tool outputs accessible as MCP resources</li>
</ul>
<h3>Example Workflow Integration:</h3>
<pre><code class="language-typescript">// MCP Prompt: &quot;analyze-and-recommend&quot;
// Generated prompt text that guides the user through:
// 1. Call analyze_repository tool
// 2. Review analysis results via documcp://analysis/{id} resource  
// 3. Call recommend_ssg tool with analysis results
// 4. Access recommendations via documcp://recommendations/{id} resource
// 5. Call generate_config with selected SSG
</code></pre>
<h2>Alternatives Considered</h2>
<h3>Alternative 1: Custom Protocol Extensions (Previous Approach)</h3>
<ul>
<li><strong>Pros</strong>: Maximum flexibility, custom AI features</li>
<li><strong>Cons</strong>: Protocol complexity, compatibility issues, non-standard</li>
<li><strong>Decision</strong>: Rejected in favor of MCP-native approach</li>
</ul>
<h3>Alternative 2: Tools-Only Approach</h3>
<ul>
<li><strong>Pros</strong>: Simple, already implemented</li>
<li><strong>Cons</strong>: No guided workflows, no template assistance, harder user experience</li>
<li><strong>Decision</strong>: Insufficient for comprehensive AI assistance</li>
</ul>
<h3>Alternative 3: External AI Service Integration</h3>
<ul>
<li><strong>Pros</strong>: Leverage existing AI platforms</li>
<li><strong>Cons</strong>: Breaks MCP cohesion, additional dependencies, latency</li>
<li><strong>Decision</strong>: Conflicts with MCP server simplicity</li>
</ul>
<h2>Consequences</h2>
<h3>Positive Consequences</h3>
<ul>
<li><strong>MCP Compliance</strong>: Uses protocol as designed, no custom extensions needed</li>
<li><strong>Client Compatibility</strong>: Works with all MCP clients (Claude Desktop, GitHub Copilot, etc.)</li>
<li><strong>Guided Workflows</strong>: Prompts provide step-by-step assistance for complex tasks</li>
<li><strong>Rich Content Access</strong>: Resources make generated content easily accessible</li>
<li><strong>Template Reusability</strong>: Prompts can be customized and reused across projects</li>
<li><strong>Simplified Architecture</strong>: No need for custom protocol handling or AI-specific interfaces</li>
</ul>
<h3>Negative Consequences</h3>
<ul>
<li><strong>Prompt Complexity</strong>: Complex workflows require sophisticated prompt engineering</li>
<li><strong>Resource Management</strong>: Need efficient resource caching and lifecycle management</li>
<li><strong>Limited AI Features</strong>: Constrained to MCP's prompt/resource model</li>
<li><strong>Template Maintenance</strong>: Prompts need regular updates as tools evolve</li>
</ul>
<h2>Implementation Plan</h2>
<h3>Phase 1: Core MCP Integration (Week 1-2)</h3>
<ol>
<li>Implement <code>ListPromptsRequestSchema</code> and <code>GetPromptRequestSchema</code> handlers</li>
<li>Implement <code>ListResourcesRequestSchema</code> and <code>ReadResourceRequestSchema</code> handlers</li>
<li>Create resource URI schema and routing system</li>
<li>Add MCP capabilities registration for prompts and resources</li>
</ol>
<h3>Phase 2: Documentation Prompts (Week 3-4)</h3>
<ol>
<li>Create &quot;analyze-and-recommend&quot; workflow prompt</li>
<li>Create &quot;setup-documentation&quot; structure prompt</li>
<li>Create &quot;troubleshoot-deployment&quot; diagnostic prompt</li>
<li>Add prompt argument validation and help text</li>
</ol>
<h3>Phase 3: Resource Management (Week 5-6)</h3>
<ol>
<li>Implement resource caching for analysis results</li>
<li>Add generated configuration file resources</li>
<li>Create template library resources</li>
<li>Add resource cleanup and lifecycle management</li>
</ol>
<h3>Phase 4: Advanced Features (Week 7-8)</h3>
<ol>
<li>Dynamic prompt generation based on project characteristics</li>
<li>Contextual resource recommendations</li>
<li>Prompt composition for complex workflows</li>
<li>Integration testing with major MCP clients</li>
</ol>
<h2>Integration with Existing Architecture</h2>
<h3>ADR-001 (MCP Server Architecture)</h3>
<ul>
<li>Extends the TypeScript MCP SDK usage to include prompts and resources</li>
<li>Maintains stateless operation model</li>
<li>Leverages existing modular design</li>
</ul>
<h3>ADR-006 (MCP Tools API Design)</h3>
<ul>
<li>Tools remain the primary interface for actions</li>
<li>Prompts provide guided workflows using existing tools</li>
<li>Resources expose tool outputs in structured format</li>
</ul>
<h3>ADR-007 (Pluggable Prompt Tool Architecture)</h3>
<ul>
<li><strong>Modified Approach</strong>: Instead of custom prompt engines, use MCP prompts</li>
<li>Template system becomes MCP prompt templates</li>
<li>Configuration-driven approach still applies for prompt customization</li>
</ul>
<h2>MCP Server Capabilities Declaration</h2>
<pre><code class="language-typescript">server.setRequestHandler(InitializeRequestSchema, async () =&gt; ({
  protocolVersion: &quot;2024-11-05&quot;,
  capabilities: {
    tools: {},           // Existing tool capabilities
    prompts: {},         // NEW: Prompt template capabilities  
    resources: {},       // NEW: Resource access capabilities
  },
  serverInfo: {
    name: &quot;documcp&quot;,
    version: &quot;0.2.0&quot;,
  },
}));
</code></pre>
<h2>Future Considerations</h2>
<ul>
<li>Integration with MCP sampling for AI-powered responses</li>
<li>Advanced prompt chaining and conditional workflows</li>
<li>Resource subscriptions for real-time updates</li>
<li>Community prompt template sharing and marketplace</li>
</ul>
